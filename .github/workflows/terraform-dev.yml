name: Terraform Dev

on:
  pull_request:
    paths:
      - "infra/environments/dev/**"
  push:
    branches:
      - main
    paths:
      - "infra/environments/dev/**"
  workflow_dispatch:
    inputs:
      action:
        description: 'Terraform action to run'
        required: true
        default: 'plan'
        type: choice
        options:
          - plan
          - apply

concurrency:
  group: terraform-dev-state
  cancel-in-progress: false

jobs:
  terraform:
    runs-on: ubuntu-latest

    env:
      ARM_CLIENT_ID:       ${{ secrets.AZURE_CLIENT_ID }}
      ARM_CLIENT_SECRET:   ${{ secrets.AZURE_CLIENT_SECRET }}
      ARM_TENANT_ID:       ${{ secrets.AZURE_TENANT_ID }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    defaults:
      run:
        working-directory: infra/environments/dev

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.5

      - name: Terraform Init
        run: terraform init -input=false

      - name: Terraform Plan
        if: github.event_name == 'pull_request' || (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'plan')
        id: terraform_plan
        continue-on-error: true
        env:
          TF_VAR_github_infra_owner:            ${{ secrets.GH_INFRA_OWNER }}
          TF_VAR_github_infra_repo:             ${{ secrets.GH_INFRA_REPO }}
          TF_VAR_github_app_id:                 ${{ secrets.GH_APP_ID }}
          TF_VAR_github_installation_id:        ${{ secrets.GH_INSTALLATION_ID }}
          TF_VAR_github_app_private_key_base64: ${{ secrets.GH_APP_PRIVATE_KEY_BASE64 }}
          TF_VAR_github_webhook_secret:         ${{ secrets.GH_WEBHOOK_SECRET }}
        run: terraform plan -input=false -no-color

      - name: Label PR with plan status
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const outcome = '${{ steps.terraform_plan.outcome }}';
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = context.issue.number;

            const PLAN_OK = 'status:plan-ok';
            const PLAN_FAILED = 'status:plan-failed';

            // Best-effort remove old plan labels
            try {
              await github.rest.issues.removeLabel({
                owner,
                repo,
                issue_number,
                name: PLAN_OK,
              });
            } catch (e) {
              // ignore if not present
            }

            try {
              await github.rest.issues.removeLabel({
                owner,
                repo,
                issue_number,
                name: PLAN_FAILED,
              });
            } catch (e) {
              // ignore if not present
            }

            const labelToAdd = outcome === 'success' ? PLAN_OK : PLAN_FAILED;

            await github.rest.issues.addLabels({
              owner,
              repo,
              issue_number,
              labels: [labelToAdd],
            });

            if (outcome !== 'success') {
              core.setFailed(`Terraform plan failed with outcome: ${outcome}`);
            }

      - name: Azure Login for State Backup
        if: (github.event_name == 'push' && github.ref == 'refs/heads/main') || (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply')
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Backup Terraform State
        if: (github.event_name == 'push' && github.ref == 'refs/heads/main') || (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply')
        id: backup_state
        run: |
          chmod +x ../../scripts/backup-tfstate.sh
          ../../scripts/backup-tfstate.sh dev

      - name: Terraform Apply
        if: (github.event_name == 'push' && github.ref == 'refs/heads/main') || (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply')
        id: terraform_apply
        continue-on-error: true
        env:
          TF_VAR_github_infra_owner:            ${{ secrets.GH_INFRA_OWNER }}
          TF_VAR_github_infra_repo:             ${{ secrets.GH_INFRA_REPO }}
          TF_VAR_github_app_id:                 ${{ secrets.GH_APP_ID }}
          TF_VAR_github_installation_id:        ${{ secrets.GH_INSTALLATION_ID }}
          TF_VAR_github_app_private_key_base64: ${{ secrets.GH_APP_PRIVATE_KEY_BASE64 }}
          TF_VAR_github_webhook_secret:         ${{ secrets.GH_WEBHOOK_SECRET }}
        run: terraform apply -input=false -auto-approve

      - name: Capture Terraform outputs
        if: (github.event_name == 'push' && github.ref == 'refs/heads/main') || (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'apply')
        id: tfoutputs
        run: terraform output -json > tf-outputs.json

      - name: Comment outputs + label apply status on associated PR
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        uses: actions/github-script@v7
        env:
          APPLY_OUTCOME: ${{ steps.terraform_apply.outcome }}
          BACKUP_BLOB: ${{ steps.backup_state.outputs.backup_blob }}
          BACKUP_TIMESTAMP: ${{ steps.backup_state.outputs.backup_timestamp }}
          BACKUP_GIT_SHA: ${{ steps.backup_state.outputs.backup_git_sha }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            // 1) Read terraform outputs JSON
            const outputsPath = path.join(
              process.cwd(),
              'infra/environments/dev/tf-outputs.json'
            );
            let outputs;
            try {
              outputs = JSON.parse(fs.readFileSync(outputsPath, 'utf8'));
            } catch (err) {
              core.warning(`Failed to read Terraform outputs at ${outputsPath}: ${err.message}`);
              outputs = null;
            }

            const applyOutcome = process.env.APPLY_OUTCOME || 'unknown';

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const commitSha = context.sha;

            // 2) Find PR(s) associated with this commit
            const { data: prs } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
              owner,
              repo,
              commit_sha: commitSha,
            });

            if (!prs || prs.length === 0) {
              core.info(`No PR found for commit ${commitSha}, skipping label/comment.`);
            } else {
              const pr = prs[0];
              const issue_number = pr.number;
              core.info(`Updating PR #${issue_number}`);

              // 2a) Update apply labels
              const APPLY_OK = 'status:apply-ok';
              const APPLY_FAILED = 'status:apply-failed';

              // Remove old apply labels if present
              try {
                await github.rest.issues.removeLabel({
                  owner,
                  repo,
                  issue_number,
                  name: APPLY_OK,
                });
              } catch (e) {
                // ignore missing
              }

              try {
                await github.rest.issues.removeLabel({
                  owner,
                  repo,
                  issue_number,
                  name: APPLY_FAILED,
                });
              } catch (e) {
                // ignore missing
              }

              const applyLabel = applyOutcome === 'success' ? APPLY_OK : APPLY_FAILED;

              await github.rest.issues.addLabels({
                owner,
                repo,
                issue_number,
                labels: [applyLabel],
              });

              // 2b) Comment backup info and TF outputs
              const backupBlob = process.env.BACKUP_BLOB || 'N/A';
              const backupTimestamp = process.env.BACKUP_TIMESTAMP || 'N/A';
              const backupGitSha = process.env.BACKUP_GIT_SHA || 'N/A';

              let body = '## Terraform Apply Result\n\n';
              body += `**Status:** ${applyOutcome === 'success' ? '✅ Success' : '❌ Failed'}\n\n`;

              // Add backup info
              body += '### State Backup\n';
              if (backupBlob !== 'N/A') {
                body += `- **Backup Created:** ${backupTimestamp}\n`;
                body += `- **Git SHA:** ${backupGitSha}\n`;
                body += `- **Blob Path:** \`${backupBlob}\`\n\n`;
                body += 'To restore this backup if needed:\n';
                body += '```bash\n';
                body += `./infra/scripts/restore-tfstate.sh dev ${backupBlob.split('/').pop()}\n`;
                body += '```\n\n';
              } else {
                body += 'No backup created (first apply or state does not exist yet)\n\n';
              }

              // Add TF outputs if we have them
              if (outputs) {
                const pretty = JSON.stringify(outputs, null, 2);
                body += '### Terraform Outputs\n\n';
                body += '```json\n';
                body += pretty + '\n';
                body += '```\n';
              }

              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number,
                body,
              });
            }

            // 3) Fail workflow if apply failed
            if (applyOutcome !== 'success') {
              core.setFailed(`Terraform apply failed with outcome: ${applyOutcome}`);
            }
